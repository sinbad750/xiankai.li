#include "config.h"
#include "main.h"
#include "i2c.h"
#include "Tas5711.h"
#include "charge.h"

#include "stm8s_spi.h"


void SPI_DSP_Init(void)
{
 	SPI_DeInit();
	SPI_Init(SPI_FIRSTBIT_MSB, SPI_BAUDRATEPRESCALER_32, SPI_MODE_MASTER, SPI_CLOCKPOLARITY_LOW, SPI_CLOCKPHASE_1EDGE, SPI_DATADIRECTION_2LINES_FULLDUPLEX, SPI_NSS_SOFT,(u8)0x07);
	SPI_Cmd(ENABLE);
}


u8 SPI_DSP_SendByte(u8 byte)
{
  /* Loop while DR register in not emplty */
  while(SPI_GetFlagStatus(SPI_FLAG_TXE) == RESET);

  /* Send byte through the SPI1 peripheral */
  SPI_SendData( byte);

  /* Wait to receive a byte */
  while(SPI_GetFlagStatus( SPI_FLAG_RXNE) == RESET);

  /* Return the byte read from the SPI bus */
  return SPI_ReceiveData();
}


u8 SPI_DSP_ReadByte(void)
{
  return (SPI_DSP_SendByte(Dummy_Byte));
}



void Dsp_Send_N_FF(u16 num)
{


  u16 i;

 for(i=0;i<num;i++)
  {
       SPI_DSP_SendByte(0xff);
  }
  
}



u8 Dsp_Write_buf(u8 *buf,u16 len)
{


  u8 i;
  u16 times;


while(len)
  {
    for(i=0;i<4;i++)
    {
       SPI_DSP_SendByte(*buf);
       buf++; 
    }
    len--;

  }

  return OK;
  
}

/*
u8 Dsp_WriteData(u8 *buf,u16 len)
{


  u8 i;
  u16 times;

  if(!READ_DSP_BSY()) return ;


  SPI_DSP_CS(0);

  SPI_DSP_SendByte(0x80);


while(len)
  {
    for(i=0;i<4;i++)
    {
       SPI_DSP_SendByte(*buf);
       buf++; 
    }
    len--;

  }
  delay_us(20);
  SPI_DSP_CS(1);

  return OK;
  
}
*/

#define REG_SIZE 26
unsigned char const akm_init_config_data[REG_SIZE][2]=
{
/*;****************************************         
; I2S/16bit/FSMode=11(48kHz/48kHz)                
;****************************************         
RI:L                                              
RD:L                                              
T,10mS                                            
RI:H                                              
T,10mS                                            
;    */ 
0xC0,0x0D,

0xC1,0x00,
0xC2,0x00,
0xC3,0x02,
0xC4,0x40,
0xC5,0x00,

0xC6,0x00,
0xC7,0x00,
0xC8,0x40,
0xC9,0x00,
0xCA,0xE1,

0xCC,0x03,
0xCD,0x00,
0xCE,0xFF,
0xCF,0x30,
0xD0,0x20,

0xD2,0x00,
0xD3,0x00,
0xD4,0xFF,
0xD5,0x30,
0xD6,0x30,

0xD7,0x30,
0xD8,0x18,
0xD9,0x18,
0xDA,0x00,
0xDB,0x00


                                                                                       
//;RD:H                                             
//[/SCRIPT]                                         

};

u8 uHAL_Akm7719_SPI_Write(u8 addr, u8 data)
{
 SPI_DSP_CS(0);
SPI_DSP_SendByte(addr);
SPI_DSP_SendByte(data);
 SPI_DSP_CS(1);
}

void vHAL_Akm7719_control_reg_init(void)
{
  u8 ii;
  for(ii=0;ii<REG_SIZE;ii++)
  	{
  	  uHAL_Akm7719_SPI_Write(akm_init_config_data[ii][0],akm_init_config_data[ii][1]);
	   Wait_For_mSec(5);
  	}
}




void  vAPP_Akm7719_Dsp_Init(void)
{
 DSP_RESET(0);
 Wait_For_mSec(10);
 DSP_RESET(1);
 SPI_DSP_CS(0);
 vHAL_Akm7719_control_reg_init(void);
 Wait_For_mSec(10);

}
///////////////////////////////////////////////////////////////////////////////////////////////////


u8 DRC_dat[20][4]=
{
        {0xFE  ,0x21  ,0xa4  ,0x72},  //   1.5,         0
	{0xFE  ,0x17  ,0x03  ,0x1f},  //   1.0,         1
	{0xFE  ,0x0c  ,0x61  ,0xcc},  //   0.8,         2
	{0xFE  ,0x07  ,0x61  ,0xCC},  //   0.5,         3
	{0xFE  ,0x01  ,0xC0  ,0x79},  //   0.0,         4
	{0xFD  ,0xFC  ,0x1F  ,0x27},  // -0.5,         5
	{0xFD  ,0xEC  ,0x7D  ,0xD4},  // -1.0,         6
	{0xFd  ,0xe1  ,0xdc  ,0x81},  // -1.5,         7
	{0xFd  ,0xd7  ,0x3b  ,0x21},  // -2.0,         8
	{0xFd  ,0xcc  ,0x99  ,0xdb},  // -2.5,         9
	{0xFd  ,0xc1  ,0xf8  ,0x89},  // -3.0,       10
	{0xFd  ,0xb7  ,0x57  ,0x36},  // -3.5,       11 
	{0xFD  ,0xAC  ,0xB5  ,0xE3},  // -4,          12
	{0xFD  ,0xa2  ,0x14  ,0x90},  // -4.5,       13
	{0xFD  ,0x97  ,0x73  ,0x3d},  // -5.0,       14 
	{0xFD  ,0x8c  ,0xd1  ,0xea},  // -5.5,       15
	{0xFD  ,0x82  ,0x30  ,0x98},  // -6.0,       16
	{0xFD  ,0x7d  ,0xf0  ,0x10},  // -6.2,       17
	{0xFD  ,0x77  ,0x8f  ,0x45},  //-6.5,        18
	{0xFD  ,0x66  ,0x5d  ,0x27}   // -7.4,       19
	
};


void  Adjust5711_DRC_Value(u8 mode)

{
  u8 wr_buff[4];
  u8 i;
  
   for(i=0;i<4;i++)
   	{
         wr_buff[i]=DRC_dat[mode][i];
   	}
   
   I2C_Write_TAS5711(0x40,wr_buff,4);
}





void AmpSoundMode(u8 mode)
{    

	

	 u8 const Fl_Fr_Test_Filter[6][20]=
	{


            	/***  High pass 50  Q0.7***/
		{ 
		0x00, 0x7F, 0x68, 0xAD, 0x0F, 0x01, 0x2E, 0xA6, 0x00, 0x7F, 0x68, 0xAD, 0x00, 0xFE, 0xD0, 0xA7, 0x0F, 0x81, 0x2D, 0xF3
		}, 
		/***  EQ  100  gain ->6   Q ->0.9 ***/
		{
		//0x00, 0x80, 0xEB, 0x75, 0x0F, 0x01, 0xDE, 0xBC, 0x00, 0x7D, 0x3B, 0x62, 0x00, 0xFE, 0x21, 0x44, 0x0F, 0x81, 0xD9, 0x29
		 //  0x00, 0x80, 0xB8, 0x1F, 0x0F, 0x01, 0xDE, 0xBC, 0x00, 0x7D, 0x6E, 0xB7, 0x00, 0xFE, 0x21, 0x44, 0x0F, 0x81, 0xD9, 0x29
		 0x00, 0x80, 0x8A, 0x5F, 0x0F, 0x01, 0xDE, 0xBC, 0x00, 0x7D, 0x9C, 0x77, 0x00, 0xFE, 0x21, 0x44, 0x0F, 0x81, 0xD9, 0x29  //100  0.9  4
		}, 
		/***  EQ  220   gain ->-5 Q->1.8   ***/
		{
		//0x00, 0x7F, 0x36, 0xD9, 0x0F, 0x03, 0xB2, 0x00, 0x00, 0x7D, 0x31, 0xF1, 0x00, 0xFC, 0x4E, 0x00, 0x0F, 0x83, 0x97, 0x36
		0x00, 0x7E, 0xC1, 0x01, 0x0F, 0x04, 0x9B, 0xB9, 0x00, 0x7C, 0xBD, 0xF7, 0x00, 0xFB, 0x64, 0x47, 0x0F, 0x84, 0x81, 0x07	//220 1.8 -7
		}, 
		/***  EQ  2500 gain ->-5   Q ->1   ***/
		{
		//0x00, 0x73, 0x49, 0x1C, 0x0F, 0x44, 0x9A, 0xB6, 0x00, 0x52, 0x9C, 0xCC, 0x00, 0xBB, 0x65, 0x4A, 0x0F, 0xBA, 0x1A, 0x17
		 0x00, 0x76, 0x33, 0xFB, 0x0F, 0x3F, 0xDC, 0xAF, 0x00, 0x54, 0xB3, 0xFF, 0x00, 0xC0, 0x23, 0x51, 0x0F, 0xB5, 0x18, 0x06 //-3
		},
		/***  EQ  5500 gain ->-3 Q ->1   ***/
		{ 	
	       //0x00, 0x73, 0x06, 0x2F, 0x0F, 0x82, 0x56, 0x38, 0x00, 0x34, 0x1D, 0xE4, 0x00, 0x7D, 0xA9, 0xC8, 0x0F, 0xD8, 0xDB, 0xEC
	          0x00, 0x77, 0x89, 0x4E, 0x0F, 0x7D, 0x68, 0x42, 0x00, 0x36, 0x29, 0x45, 0x00, 0x82, 0x97, 0xBE, 0x0F, 0xD2, 0x4D, 0x6C
		} ,
		/***  EQ  15000 gain ->-3 Q ->1   ***/
		{ 	
	      // 0x00, 0x5E, 0xA1, 0x80, 0x00, 0x0A, 0x84, 0xC9, 0x0F, 0xBC, 0xDB, 0x18, 0x0F, 0xF5, 0x7B, 0x37, 0x00, 0x64, 0x83, 0x68  //Q0.7
		// 0x00, 0x66, 0x9F, 0x2F, 0x00, 0x1F, 0x75, 0xC5, 0x0F, 0xEB, 0x96, 0x57, 0x0F, 0xE0, 0x8A, 0x3B, 0x00, 0x2D, 0xCA, 0x7A  	//Q1.0
		// 0x00, 0x68, 0xCD, 0xF4, 0x00, 0x0B, 0xA6, 0x49, 0x0F, 0xB5, 0xA3, 0x22, 0x0F, 0xF4, 0x59, 0xB7, 0x00, 0x61, 0x8E, 0xE9
		     0x00, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x3A, 0x54, 0x0F, 0xA5, 0x2D, 0xDE, 0x0F, 0xF1, 0xC5, 0xAC, 0x00, 0x5A, 0xD2, 0x22 //15000 0.7  0
		} 


           //  00  80  00  00  00  0E  3A  54  0F  A5  2D  DE  0F  F1  C5  AC  00  5A  D2  22 

	};

	 u8 const Fl_Fr_Test_Filter2[6][20]=
	{

		/***  bypass all   ***/
		{ 
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		}, 
		{
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		}, 
		{
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		}, 
		{
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		},
		{ 
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		} ,
		{ 
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		} 

	};

	 u8 const Fl_Fr_Test_Filter3[6][20]=
	{     
	      /***  bypass all   ***/
		{ 
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		}, 
	      /***  bypass all   ***/
		{
	        0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		}, 
		/***  EQ  220   gain ->-2 Q->1.8   ***/
		{
		 0x00, 0x7F, 0xBC, 0xCD, 0x0F, 0x02, 0xA8, 0x54, 0x00, 0x7D, 0xB5, 0xC5, 0x00, 0xFD, 0x57, 0xAC, 0x0F, 0x82, 0x8D, 0x6D
		}, 
		/***  EQ  2500 gain ->-2  Q ->1   ***/
		{
		0x00, 0x7B, 0x78, 0x42, 0x0F, 0x37, 0x4D, 0x12, 0x00, 0x58, 0x7A, 0x28, 0x00, 0xC8, 0xB2, 0xEE, 0x0F, 0xAC, 0x0D, 0x95
		},
		/***  bypass  ***/
		{ 	
	       0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		} ,
	       /***  bypass  ***/
		{ 	
	       0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		} 


	};

	 	

	u8 i;
	//TAS5711_mute(MUTE_ON);
	//return;	////////////////////////////attention
	

	
	for(i=0;i<6;i++)
	{
		if(mode==1)
		{
	        	I2C_Write_TAS5711(0x2a+i,&Fl_Fr_Test_Filter[i][0],20);
			I2C_Write_TAS5711(0x31+i,&Fl_Fr_Test_Filter[i][0],20);
		
		}

		if(mode==2)
		{
			I2C_Write_TAS5711(0x2a+i,&Fl_Fr_Test_Filter2[i][0],20);
			I2C_Write_TAS5711(0x31+i,&Fl_Fr_Test_Filter2[i][0],20);
			
		}
		
		if(mode==3)
		{
			I2C_Write_TAS5711(0x2a+i,&Fl_Fr_Test_Filter3[i][0],20);
			I2C_Write_TAS5711(0x31+i,&Fl_Fr_Test_Filter3[i][0],20);
			
		}
		
	}

    
}




void Write_TAS5711_FLFR_DRC(void)
{

	u8  Energy[8]={0x00  ,0x00  ,0x94  ,0x43  ,0x00  ,0x7F  ,0x6B  ,0xB9};
	u8  Attack[8]= {0x00  ,0x00  ,0x4A  ,0x37  ,0x00  ,0x7F  ,0xB5  ,0xC5};
      u8  T[4]= {0xFE  ,0x21  ,0xa4  ,0x72 };
//	u8  T[4]= {0xFE  ,0x7C  ,0x0D  ,0xB6 };
	u8  K[4]= {0x0F  ,0x82  ,0x53  ,0xC9};
	u8  O[4]= {0x00  ,0x08  ,0x42  ,0x10};
		   
	I2C_Write_TAS5711(0x3a,&Energy[0],8);
	I2C_Write_TAS5711(0x40,&T[0], 4);
	I2C_Write_TAS5711(0x41,&K[0], 4);
	I2C_Write_TAS5711(0x42,&O[0], 4);
	I2C_Write_TAS5711(0x3b,&Attack[0],8);
	I2C_Write_TAS5711(0x3c,&Attack[0],8);


}

void Write_BT_DRC(void)
{

	u8  Energy[8]={0x00, 0x00, 0x03, 0x69, 0x00, 0x7F, 0xFC, 0x96};
	u8  Attack[8]= {0x00, 0x00, 0xE2, 0xC4, 0x00, 0x7F, 0x1D, 0x3B};
	u8  Attack1[8]={ 0x00, 0x00, 0x03, 0x69, 0x00, 0x7F, 0xFC, 0x96};
       u8  T[4]= {0xFD, 0x62, 0x4C, 0x9F};
	u8  K[4]= {0x0F, 0xBA, 0xAA, 0xAC};
	u8  O[4]= {0x00  ,0x08  ,0x42  ,0x10};
		   
	I2C_Write_TAS5711(0x3a,&Energy[0],8);
	I2C_Write_TAS5711(0x40,&T[0], 4);
	I2C_Write_TAS5711(0x41,&K[0], 4);
	I2C_Write_TAS5711(0x42,&O[0], 4);
	I2C_Write_TAS5711(0x3b,&Attack[0],8);
	I2C_Write_TAS5711(0x3c,&Attack1[0],8);
      // 12%  9.8W
      // 2%  8W

}

void TAS5711_Reset(void)
{
	Write_TAS5711_Reset(0);
	Wait_For_mSec(100);
	Write_TAS5711_Reset(1);	
	Wait_For_mSec(10);
}

void TAS5711_Hard_Mute(u8 enable_mute)
{

	u8 hard_mute=0;
	
	if(enable_mute==1)
	{
		hard_mute=0x40;
	
	}
	else
	{
		hard_mute=0x00;
	}
	I2C_Write_TAS5711(0X05,&hard_mute,1);


}


void TAS5711_mute(u8 onoff)
{
   u8  data;
     if(onoff==0)
     	{
     	data=0x00;
	I2C_Write_TAS5711(0x06,&data,1);
     	}
     else
     	{
     	 data=0x3f;
	I2C_Write_TAS5711(0x06,&data,1);
     	}
}


void TAS5711_vol(u8 vol)
{
        u8  data;

	if(vol)
		{
        data=vol;
	I2C_Write_TAS5711(0x08,&data,1);
	I2C_Write_TAS5711(0x09,&data,1);
		}
}


void PWM_EMC_Control(void)
{
        u8 data=0x30;
		  if(LR_Flag==0)
		data=0x30;
	       else if(LR_Flag==2)
	  	data=0x3A;
	        else if(LR_Flag==1)
	  	data=0x35;

			
		//data=0x30;	
		I2C_Write_TAS5711(0x19,&data,1);

}


void Tas5711_Init(void)
{

 	u8  data=0x00;
	u8 data2[4]={0x00,0x01,0x77,0x72};
	u8 data3[4]={0x00,0x00,0x42,0x03};
	u8 dataL[4]={0x01,0x13,0x02,0x45};
	u8 data5[4]={0x00,0x00,0x00,0x03};

        TAS5711_Reset();
	//i2cSlaveAddress = 0x36; 
	
	data = 0x00;
	I2C_Write_TAS5711(0x1B,&data,1);


       //data = 0x0c;
	//I2C_Write_TAS5711(0x00,&data,1);

	
	Wait_For_mSec(60);
        //   data=0x3f;
        //I2C_Write_TAS5711(0x06,&data,1); // mute
	
	I2C_Write_TAS5711(0x20,data2,4);
	I2C_Write_TAS5711(0x21,data3,4);
	I2C_Write_TAS5711(0x25,dataL,4); 	
	data=0xB8;
	I2C_Write_TAS5711(0x11,&data,1);
	data=0x60;
	I2C_Write_TAS5711(0x12,&data,1);
	data=0xA0;
	I2C_Write_TAS5711(0x13,&data,1);
	data=0x48;
	I2C_Write_TAS5711(0x14,&data,1);
	data=0x80;
	I2C_Write_TAS5711(0x03,&data,1);
	//data=0x0f;
	data=0x80;
       I2C_Write_TAS5711(0x1a,&data,1);

	   PWM_EMC_Control();
	data=0x3c;
	I2C_Write_TAS5711(0x46,data5,4);   
	 data=0x00;
	//data=0x20;
	I2C_Write_TAS5711(0x05,&data,1); //
	data=0x00;
	I2C_Write_TAS5711(0x07,&data,1); //master vol
	data=0xfc;
	I2C_Write_TAS5711(0x08,&data,1);// ch1 vol
	data=0xfc;
	I2C_Write_TAS5711(0x09,&data,1); //ch2 vol
	data=0xfc;
	I2C_Write_TAS5711(0x0a,&data,1); // ch3 vol
        data=0x3f;
        I2C_Write_TAS5711(0x06,&data,1); // mute
	Wait_For_mSec(5);
	Write_TAS5711_FLFR_DRC();
        AmpSoundMode(1);
	/*
     if(Main_Link_Status())
	AmpSoundMode(2);
	   else
	AmpSoundMode(1);
	*/
	
}






void  MONO_BT_Sound(void)

{
   
	u8  data;
       
	u8 MIX1[16]={
				0x00, 0x00, 0x00, 0x00, 
				0x00, 0x80, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 
				0x00, 0x80, 0x00, 0x00
				};	
					 
	u8 MIX2[12]={
                               0x00, 0x00, 0x00, 0x00, 
                               0x00, 0x40, 0x00, 0x00, 
                               0x00, 0x40, 0x00, 0x00
                              };
		

	Tas5711_Init();	
	I2C_Write_TAS5711(0x55,MIX2,12);
	I2C_Write_TAS5711(0x53,MIX1,16); 
	I2C_Write_TAS5711(0x54,MIX1,16);
	//Adjust5711_DRC_Value(12);
	Write_BT_DRC();
//	AmpSoundMode(1);
	Wait_For_mSec(10);
	//data=0x48;  //VOL 61
	data=0x52;
	I2C_Write_TAS5711(0x08,&data,1);
	I2C_Write_TAS5711(0x09,&data,1); 
	TAS5711_mute(0);
	
}


void  SOD_STEREO_Sound(void)
	
{

	u8  data;
	
	u8 MIX1[16]={
                              0x00, 0x80, 0x00, 0x00, 
                              0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00, 
                              0x00, 0x80, 0x00, 0x00
                              };
		
	u8 MIX2[12]={
	
                              0x00, 0x80, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00
                              };		
     							  
         Tas5711_Init();						  
	I2C_Write_TAS5711(0x55,MIX2,12);
	I2C_Write_TAS5711(0x53,MIX1,16); 
	I2C_Write_TAS5711(0x54,MIX1,16);
      
	//AmpSoundMode(1);
	Wait_For_mSec(10);
	if(Sys_state==Stereo_state)
		{
	        Write_BT_DRC();
		//AmpSoundMode(1);
	if(LR_Flag==2)
	//data=0x61; //VOL
	data=0x56;
	else 
	data=0x56; //VOL
       I2C_Write_TAS5711(0x08,&data,1);
	I2C_Write_TAS5711(0x09,&data,1);
	//if(bt_poweroff_time==0)
	 TAS5711_mute(0);
	}
	else
		{
              // AmpSoundMode(2);
              ;
		
		}


	
}
	

